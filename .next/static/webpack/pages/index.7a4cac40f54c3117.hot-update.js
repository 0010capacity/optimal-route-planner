"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./src/hooks/useMap.js":
/*!*****************************!*\
  !*** ./src/hooks/useMap.js ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMap: () => (/* binding */ useMap)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar _s = $RefreshSig$();\n\nconst DEFAULT_CENTER = {\n    lat: 37.5665,\n    lng: 126.9780\n};\n// 모바일 기기 감지\nconst isMobileDevice = ()=>{\n    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;\n};\n// 모바일에 최적화된 위치 옵션\nconst getGeolocationOptions = ()=>{\n    const isMobile = isMobileDevice();\n    return {\n        enableHighAccuracy: !isMobile,\n        timeout: isMobile ? 20000 : 10000,\n        maximumAge: 300000\n    };\n};\nconst useMap = ()=>{\n    _s();\n    const [mapCenter, setMapCenter] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(DEFAULT_CENTER);\n    const [userLocation, setUserLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [mapInstance, setMapInstance] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isGettingLocation, setIsGettingLocation] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const markersRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const polylineRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // 지도 초기화\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMap.useEffect\": ()=>{\n            console.log('useMap useEffect 실행됨');\n            console.log('mapRef.current:', mapRef.current);\n            console.log('window.naver:', window.naver);\n            console.log('window.naver.maps:', window.naver?.maps);\n            if (false) {}\n            // 지도 컨테이너가 준비될 때까지 기다림\n            const waitForMapContainer = {\n                \"useMap.useEffect.waitForMapContainer\": ()=>{\n                    if (!mapRef.current) {\n                        console.log('지도 컨테이너 대기 중...');\n                        setTimeout(waitForMapContainer, 100);\n                        return;\n                    }\n                    console.log('지도 컨테이너 준비됨:', mapRef.current);\n                    // 네이버 지도 SDK가 로드될 때까지 기다림\n                    const initMap = {\n                        \"useMap.useEffect.waitForMapContainer.initMap\": ()=>{\n                            console.log('initMap 함수 실행');\n                            if (!window.naver || !window.naver.maps) {\n                                console.log('네이버 지도 SDK 대기 중...');\n                                setTimeout(initMap, 100);\n                                return;\n                            }\n                            try {\n                                console.log('지도 초기화 시작...');\n                                console.log('지도 컨테이너:', mapRef.current);\n                                const map = new window.naver.maps.Map(mapRef.current, {\n                                    center: new window.naver.maps.LatLng(mapCenter.lat, mapCenter.lng),\n                                    zoom: 13,\n                                    minZoom: 7,\n                                    maxZoom: 21\n                                });\n                                setMapInstance(map);\n                                console.log('지도 인스턴스 생성 완료');\n                                window.naver.maps.Event.addListener(map, 'center_changed', {\n                                    \"useMap.useEffect.waitForMapContainer.initMap\": ()=>{\n                                        const center = map.getCenter();\n                                        setMapCenter({\n                                            lat: center.lat(),\n                                            lng: center.lng()\n                                        });\n                                    }\n                                }[\"useMap.useEffect.waitForMapContainer.initMap\"]);\n                                console.log('지도 초기화 완료');\n                            } catch (error) {\n                                console.error('지도 초기화 오류:', error);\n                                console.error('에러 상세:', error.message);\n                                console.error('에러 스택:', error.stack);\n                            }\n                        }\n                    }[\"useMap.useEffect.waitForMapContainer.initMap\"];\n                    // 약간의 지연 후 초기화 시작\n                    setTimeout(initMap, 100);\n                }\n            }[\"useMap.useEffect.waitForMapContainer\"];\n            waitForMapContainer();\n            return ({\n                \"useMap.useEffect\": ()=>{\n                    if (mapInstance) {\n                        markersRef.current.forEach({\n                            \"useMap.useEffect\": (marker)=>marker.setMap(null)\n                        }[\"useMap.useEffect\"]);\n                        markersRef.current = [];\n                        if (polylineRef.current) {\n                            polylineRef.current.setMap(null);\n                            polylineRef.current = null;\n                        }\n                    }\n                }\n            })[\"useMap.useEffect\"];\n        }\n    }[\"useMap.useEffect\"], []);\n    // 지도 중심 업데이트\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMap.useEffect\": ()=>{\n            if (mapInstance && mapCenter) {\n                mapInstance.setCenter(new window.naver.maps.LatLng(mapCenter.lat, mapCenter.lng));\n            }\n        }\n    }[\"useMap.useEffect\"], [\n        mapCenter,\n        mapInstance\n    ]);\n    const moveMapToLocation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMap.useCallback[moveMapToLocation]\": (coords)=>{\n            setMapCenter(coords);\n            if (mapInstance) {\n                try {\n                    mapInstance.setCenter(new window.naver.maps.LatLng(coords.lat, coords.lng));\n                } catch (error) {\n                    console.error('Error moving map:', error);\n                }\n            }\n        }\n    }[\"useMap.useCallback[moveMapToLocation]\"], [\n        mapInstance\n    ]);\n    const getCurrentLocation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMap.useCallback[getCurrentLocation]\": ()=>{\n            // HTTPS 확인 (Geolocation API는 HTTPS에서만 작동)\n            if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {\n                alert('위치 서비스는 HTTPS 환경에서만 사용할 수 있습니다.');\n                return;\n            }\n            if (!navigator.geolocation) {\n                console.warn('이 브라우저는 위치 서비스를 지원하지 않습니다.');\n                alert('이 브라우저는 위치 서비스를 지원하지 않습니다.');\n                return;\n            }\n            setIsGettingLocation(true);\n            const options = getGeolocationOptions();\n            const isMobile = isMobileDevice();\n            // 모바일에서는 사용자에게 위치 권한 요청 안내\n            if (isMobile && navigator.permissions) {\n                navigator.permissions.query({\n                    name: 'geolocation'\n                }).then({\n                    \"useMap.useCallback[getCurrentLocation]\": (result)=>{\n                        if (result.state === 'denied') {\n                            alert('위치 권한이 거부되었습니다. 브라우저 설정에서 위치 권한을 허용해주세요.');\n                            setIsGettingLocation(false);\n                            return;\n                        }\n                    }\n                }[\"useMap.useCallback[getCurrentLocation]\"]).catch({\n                    \"useMap.useCallback[getCurrentLocation]\": ()=>{\n                    // 권한 API를 지원하지 않는 브라우저에서는 무시\n                    }\n                }[\"useMap.useCallback[getCurrentLocation]\"]);\n            }\n            const getLocation = {\n                \"useMap.useCallback[getCurrentLocation].getLocation\": ()=>{\n                    navigator.geolocation.getCurrentPosition({\n                        \"useMap.useCallback[getCurrentLocation].getLocation\": (position)=>{\n                            const { latitude, longitude, accuracy } = position.coords;\n                            console.log('위치 정보 획득 성공:', {\n                                latitude,\n                                longitude,\n                                accuracy\n                            });\n                            const newLocation = {\n                                lat: latitude,\n                                lng: longitude\n                            };\n                            setUserLocation(newLocation);\n                            moveMapToLocation(newLocation);\n                            setIsGettingLocation(false);\n                        }\n                    }[\"useMap.useCallback[getCurrentLocation].getLocation\"], {\n                        \"useMap.useCallback[getCurrentLocation].getLocation\": (error)=>{\n                            console.error('위치 서비스 오류:', error);\n                            setIsGettingLocation(false);\n                            let errorMessage = '현재 위치를 가져올 수 없습니다.';\n                            switch(error.code){\n                                case error.PERMISSION_DENIED:\n                                    errorMessage = '위치 권한이 거부되었습니다. 브라우저 설정에서 위치 권한을 허용해주세요.';\n                                    break;\n                                case error.POSITION_UNAVAILABLE:\n                                    errorMessage = '위치 정보를 사용할 수 없습니다. GPS 신호를 확인해주세요.';\n                                    break;\n                                case error.TIMEOUT:\n                                    errorMessage = '위치 정보 요청이 시간 초과되었습니다. 다시 시도해주세요.';\n                                    break;\n                                default:\n                                    errorMessage = `위치 정보 오류: ${error.message}`;\n                                    break;\n                            }\n                            alert(errorMessage);\n                            // 모바일에서는 정확도 낮춰서 재시도\n                            if (isMobile && options.enableHighAccuracy && error.code === error.TIMEOUT) {\n                                console.log('정확도 낮춰서 재시도...');\n                                setTimeout({\n                                    \"useMap.useCallback[getCurrentLocation].getLocation\": ()=>{\n                                        navigator.geolocation.getCurrentPosition({\n                                            \"useMap.useCallback[getCurrentLocation].getLocation\": (position)=>{\n                                                const { latitude, longitude } = position.coords;\n                                                const newLocation = {\n                                                    lat: latitude,\n                                                    lng: longitude\n                                                };\n                                                setUserLocation(newLocation);\n                                                moveMapToLocation(newLocation);\n                                                setIsGettingLocation(false);\n                                            }\n                                        }[\"useMap.useCallback[getCurrentLocation].getLocation\"], {\n                                            \"useMap.useCallback[getCurrentLocation].getLocation\": (retryError)=>{\n                                                console.error('재시도 실패:', retryError);\n                                                setIsGettingLocation(false);\n                                            }\n                                        }[\"useMap.useCallback[getCurrentLocation].getLocation\"], {\n                                            ...options,\n                                            enableHighAccuracy: false,\n                                            timeout: 15000\n                                        });\n                                    }\n                                }[\"useMap.useCallback[getCurrentLocation].getLocation\"], 1000);\n                            }\n                        }\n                    }[\"useMap.useCallback[getCurrentLocation].getLocation\"], options);\n                }\n            }[\"useMap.useCallback[getCurrentLocation].getLocation\"];\n            getLocation();\n        }\n    }[\"useMap.useCallback[getCurrentLocation]\"], [\n        moveMapToLocation\n    ]);\n    return {\n        mapRef,\n        mapCenter,\n        setMapCenter,\n        userLocation,\n        mapInstance,\n        markersRef,\n        polylineRef,\n        moveMapToLocation,\n        getCurrentLocation,\n        isGettingLocation\n    };\n};\n_s(useMap, \"nrdaNUIqB2M5D2mQm/fdf89bfIk=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9ob29rcy91c2VNYXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpRTtBQUVqRSxNQUFNSSxpQkFBaUI7SUFBRUMsS0FBSztJQUFTQyxLQUFLO0FBQVM7QUFFckQsWUFBWTtBQUNaLE1BQU1DLGlCQUFpQjtJQUNyQixPQUFPLGlFQUFpRUMsSUFBSSxDQUFDQyxVQUFVQyxTQUFTLEtBQ3pGQyxPQUFPQyxVQUFVLElBQUk7QUFDOUI7QUFFQSxrQkFBa0I7QUFDbEIsTUFBTUMsd0JBQXdCO0lBQzVCLE1BQU1DLFdBQVdQO0lBRWpCLE9BQU87UUFDTFEsb0JBQW9CLENBQUNEO1FBQ3JCRSxTQUFTRixXQUFXLFFBQVE7UUFDNUJHLFlBQVk7SUFDZDtBQUNGO0FBRU8sTUFBTUMsU0FBUzs7SUFDcEIsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUdwQiwrQ0FBUUEsQ0FBQ0k7SUFDM0MsTUFBTSxDQUFDaUIsY0FBY0MsZ0JBQWdCLEdBQUd0QiwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUN1QixhQUFhQyxlQUFlLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUN5QixtQkFBbUJDLHFCQUFxQixHQUFHMUIsK0NBQVFBLENBQUM7SUFDM0QsTUFBTTJCLFNBQVN6Qiw2Q0FBTUEsQ0FBQztJQUN0QixNQUFNMEIsYUFBYTFCLDZDQUFNQSxDQUFDLEVBQUU7SUFDNUIsTUFBTTJCLGNBQWMzQiw2Q0FBTUEsQ0FBQztJQUUzQixTQUFTO0lBQ1RELGdEQUFTQTs0QkFBQztZQUNSNkIsUUFBUUMsR0FBRyxDQUFDO1lBQ1pELFFBQVFDLEdBQUcsQ0FBQyxtQkFBbUJKLE9BQU9LLE9BQU87WUFDN0NGLFFBQVFDLEdBQUcsQ0FBQyxpQkFBaUJwQixPQUFPc0IsS0FBSztZQUN6Q0gsUUFBUUMsR0FBRyxDQUFDLHNCQUFzQnBCLE9BQU9zQixLQUFLLEVBQUVDO1lBRWhELElBQUksS0FBNkIsRUFBRSxFQUdsQztZQUVELHVCQUF1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cnMvd29uL0RvY3VtZW50cy9HaXRIdWIvb3B0aW1hbC1yb3V0ZS1wbGFubmVyL3NyYy9ob29rcy91c2VNYXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgREVGQVVMVF9DRU5URVIgPSB7IGxhdDogMzcuNTY2NSwgbG5nOiAxMjYuOTc4MCB9O1xuXG4vLyDrqqjrsJTsnbwg6riw6riwIOqwkOyngFxuY29uc3QgaXNNb2JpbGVEZXZpY2UgPSAoKSA9PiB7XG4gIHJldHVybiAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHxcbiAgICAgICAgIHdpbmRvdy5pbm5lcldpZHRoIDw9IDc2ODtcbn07XG5cbi8vIOuqqOuwlOydvOyXkCDstZzsoIHtmZTrkJwg7JyE7LmYIOyYteyFmFxuY29uc3QgZ2V0R2VvbG9jYXRpb25PcHRpb25zID0gKCkgPT4ge1xuICBjb25zdCBpc01vYmlsZSA9IGlzTW9iaWxlRGV2aWNlKCk7XG4gIFxuICByZXR1cm4ge1xuICAgIGVuYWJsZUhpZ2hBY2N1cmFjeTogIWlzTW9iaWxlLCAvLyDrqqjrsJTsnbzsl5DshJzripQg7KCV7ZmV64+EIOuCruy2sOyEnCDsho3rj4Qg7Zal7IOBXG4gICAgdGltZW91dDogaXNNb2JpbGUgPyAyMDAwMCA6IDEwMDAwLCAvLyDrqqjrsJTsnbzsl5DshJzripQg642UIOq4tCDtg4DsnoTslYTsm4NcbiAgICBtYXhpbXVtQWdlOiAzMDAwMDBcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VNYXAgPSAoKSA9PiB7XG4gIGNvbnN0IFttYXBDZW50ZXIsIHNldE1hcENlbnRlcl0gPSB1c2VTdGF0ZShERUZBVUxUX0NFTlRFUik7XG4gIGNvbnN0IFt1c2VyTG9jYXRpb24sIHNldFVzZXJMb2NhdGlvbl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW21hcEluc3RhbmNlLCBzZXRNYXBJbnN0YW5jZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2lzR2V0dGluZ0xvY2F0aW9uLCBzZXRJc0dldHRpbmdMb2NhdGlvbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IG1hcFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgbWFya2Vyc1JlZiA9IHVzZVJlZihbXSk7XG4gIGNvbnN0IHBvbHlsaW5lUmVmID0gdXNlUmVmKG51bGwpO1xuXG4gIC8vIOyngOuPhCDstIjquLDtmZRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygndXNlTWFwIHVzZUVmZmVjdCDsi6TtlonrkKgnKTtcbiAgICBjb25zb2xlLmxvZygnbWFwUmVmLmN1cnJlbnQ6JywgbWFwUmVmLmN1cnJlbnQpO1xuICAgIGNvbnNvbGUubG9nKCd3aW5kb3cubmF2ZXI6Jywgd2luZG93Lm5hdmVyKTtcbiAgICBjb25zb2xlLmxvZygnd2luZG93Lm5hdmVyLm1hcHM6Jywgd2luZG93Lm5hdmVyPy5tYXBzKTtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5sb2coJ+yEnOuyhCDsgqzsnbTrk5zsl5DshJzripQg7Iuk7ZaJ7ZWY7KeAIOyViuydjCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIOyngOuPhCDsu6jthYzsnbTrhIjqsIAg7KSA67mE65CgIOuVjOq5jOyngCDquLDri6TrprxcbiAgICBjb25zdCB3YWl0Rm9yTWFwQ29udGFpbmVyID0gKCkgPT4ge1xuICAgICAgaWYgKCFtYXBSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zb2xlLmxvZygn7KeA64+EIOy7qO2FjOydtOuEiCDrjIDquLAg7KSRLi4uJyk7XG4gICAgICAgIHNldFRpbWVvdXQod2FpdEZvck1hcENvbnRhaW5lciwgMTAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygn7KeA64+EIOy7qO2FjOydtOuEiCDspIDruYTrkKg6JywgbWFwUmVmLmN1cnJlbnQpO1xuXG4gICAgICAvLyDrhKTsnbTrsoQg7KeA64+EIFNES+qwgCDroZzrk5zrkKAg65WM6rmM7KeAIOq4sOuLpOumvFxuICAgICAgY29uc3QgaW5pdE1hcCA9ICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2luaXRNYXAg7ZWo7IiYIOyLpO2WiScpO1xuICAgICAgICBpZiAoIXdpbmRvdy5uYXZlciB8fCAhd2luZG93Lm5hdmVyLm1hcHMpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn64Sk7J2067KEIOyngOuPhCBTREsg64yA6riwIOykkS4uLicpO1xuICAgICAgICAgIHNldFRpbWVvdXQoaW5pdE1hcCwgMTAwKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfsp4Drj4Qg7LSI6riw7ZmUIOyLnOyekS4uLicpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfsp4Drj4Qg7Luo7YWM7J2064SIOicsIG1hcFJlZi5jdXJyZW50KTtcbiAgICAgICAgICBjb25zdCBtYXAgPSBuZXcgd2luZG93Lm5hdmVyLm1hcHMuTWFwKG1hcFJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICBjZW50ZXI6IG5ldyB3aW5kb3cubmF2ZXIubWFwcy5MYXRMbmcobWFwQ2VudGVyLmxhdCwgbWFwQ2VudGVyLmxuZyksXG4gICAgICAgICAgICB6b29tOiAxMyxcbiAgICAgICAgICAgIG1pblpvb206IDcsXG4gICAgICAgICAgICBtYXhab29tOiAyMVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgc2V0TWFwSW5zdGFuY2UobWFwKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygn7KeA64+EIOyduOyKpO2EtOyKpCDsg53shLEg7JmE66OMJyk7XG5cbiAgICAgICAgICB3aW5kb3cubmF2ZXIubWFwcy5FdmVudC5hZGRMaXN0ZW5lcihtYXAsICdjZW50ZXJfY2hhbmdlZCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIHNldE1hcENlbnRlcih7XG4gICAgICAgICAgICAgIGxhdDogY2VudGVyLmxhdCgpLFxuICAgICAgICAgICAgICBsbmc6IGNlbnRlci5sbmcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zb2xlLmxvZygn7KeA64+EIOy0iOq4sO2ZlCDsmYTro4wnKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfsp4Drj4Qg7LSI6riw7ZmUIOyYpOulmDonLCBlcnJvcik7XG4gICAgICAgICAgY29uc29sZS5lcnJvcign7JeQ65+sIOyDgeyEuDonLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfsl5Drn6wg7Iqk7YOdOicsIGVycm9yLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8g7JW96rCE7J2YIOyngOyXsCDtm4Qg7LSI6riw7ZmUIOyLnOyekVxuICAgICAgc2V0VGltZW91dChpbml0TWFwLCAxMDApO1xuICAgIH07XG5cbiAgICB3YWl0Rm9yTWFwQ29udGFpbmVyKCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKG1hcEluc3RhbmNlKSB7XG4gICAgICAgIG1hcmtlcnNSZWYuY3VycmVudC5mb3JFYWNoKG1hcmtlciA9PiBtYXJrZXIuc2V0TWFwKG51bGwpKTtcbiAgICAgICAgbWFya2Vyc1JlZi5jdXJyZW50ID0gW107XG4gICAgICAgIGlmIChwb2x5bGluZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcG9seWxpbmVSZWYuY3VycmVudC5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgcG9seWxpbmVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8g7KeA64+EIOykkeyLrCDsl4XrjbDsnbTtirhcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWFwSW5zdGFuY2UgJiYgbWFwQ2VudGVyKSB7XG4gICAgICBtYXBJbnN0YW5jZS5zZXRDZW50ZXIobmV3IHdpbmRvdy5uYXZlci5tYXBzLkxhdExuZyhtYXBDZW50ZXIubGF0LCBtYXBDZW50ZXIubG5nKSk7XG4gICAgfVxuICB9LCBbbWFwQ2VudGVyLCBtYXBJbnN0YW5jZV0pO1xuXG4gIGNvbnN0IG1vdmVNYXBUb0xvY2F0aW9uID0gdXNlQ2FsbGJhY2soKGNvb3JkcykgPT4ge1xuICAgIHNldE1hcENlbnRlcihjb29yZHMpO1xuICAgIGlmIChtYXBJbnN0YW5jZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWFwSW5zdGFuY2Uuc2V0Q2VudGVyKG5ldyB3aW5kb3cubmF2ZXIubWFwcy5MYXRMbmcoY29vcmRzLmxhdCwgY29vcmRzLmxuZykpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbW92aW5nIG1hcDonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9LCBbbWFwSW5zdGFuY2VdKTtcblxuICBjb25zdCBnZXRDdXJyZW50TG9jYXRpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgLy8gSFRUUFMg7ZmV7J24IChHZW9sb2NhdGlvbiBBUEnripQgSFRUUFPsl5DshJzrp4wg7J6R64+ZKVxuICAgIGlmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgIT09ICdodHRwczonICYmIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSAhPT0gJ2xvY2FsaG9zdCcpIHtcbiAgICAgIGFsZXJ0KCfsnITsuZgg7ISc67mE7Iqk64qUIEhUVFBTIO2ZmOqyveyXkOyEnOunjCDsgqzsmqntlaAg7IiYIOyeiOyKteuLiOuLpC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xuICAgICAgY29uc29sZS53YXJuKCfsnbQg67iM65287Jqw7KCA64qUIOychOy5mCDshJzruYTsiqTrpbwg7KeA7JuQ7ZWY7KeAIOyViuyKteuLiOuLpC4nKTtcbiAgICAgIGFsZXJ0KCfsnbQg67iM65287Jqw7KCA64qUIOychOy5mCDshJzruYTsiqTrpbwg7KeA7JuQ7ZWY7KeAIOyViuyKteuLiOuLpC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRJc0dldHRpbmdMb2NhdGlvbih0cnVlKTtcbiAgICBjb25zdCBvcHRpb25zID0gZ2V0R2VvbG9jYXRpb25PcHRpb25zKCk7XG4gICAgY29uc3QgaXNNb2JpbGUgPSBpc01vYmlsZURldmljZSgpO1xuXG4gICAgLy8g66qo67CU7J287JeQ7ISc64qUIOyCrOyaqeyekOyXkOqyjCDsnITsuZgg6raM7ZWcIOyalOyyrSDslYjrgrRcbiAgICBpZiAoaXNNb2JpbGUgJiYgbmF2aWdhdG9yLnBlcm1pc3Npb25zKSB7XG4gICAgICBuYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnkoeyBuYW1lOiAnZ2VvbG9jYXRpb24nIH0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAocmVzdWx0LnN0YXRlID09PSAnZGVuaWVkJykge1xuICAgICAgICAgIGFsZXJ0KCfsnITsuZgg6raM7ZWc7J20IOqxsOu2gOuQmOyXiOyKteuLiOuLpC4g67iM65287Jqw7KCAIOyEpOygleyXkOyEnCDsnITsuZgg6raM7ZWc7J2EIO2XiOyaqe2VtOyjvOyEuOyalC4nKTtcbiAgICAgICAgICBzZXRJc0dldHRpbmdMb2NhdGlvbihmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgIC8vIOq2jO2VnCBBUEnrpbwg7KeA7JuQ7ZWY7KeAIOyViuuKlCDruIzrnbzsmrDsoIDsl5DshJzripQg66y07IucXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBnZXRMb2NhdGlvbiA9ICgpID0+IHtcbiAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oXG4gICAgICAgIChwb3NpdGlvbikgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgYWNjdXJhY3kgfSA9IHBvc2l0aW9uLmNvb3JkcztcbiAgICAgICAgICBjb25zb2xlLmxvZygn7JyE7LmYIOygleuztCDtmo3rk50g7ISx6rO1OicsIHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgYWNjdXJhY3kgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgbmV3TG9jYXRpb24gPSB7IGxhdDogbGF0aXR1ZGUsIGxuZzogbG9uZ2l0dWRlIH07XG4gICAgICAgICAgc2V0VXNlckxvY2F0aW9uKG5ld0xvY2F0aW9uKTtcbiAgICAgICAgICBtb3ZlTWFwVG9Mb2NhdGlvbihuZXdMb2NhdGlvbik7XG4gICAgICAgICAgc2V0SXNHZXR0aW5nTG9jYXRpb24oZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfsnITsuZgg7ISc67mE7IqkIOyYpOulmDonLCBlcnJvcik7XG4gICAgICAgICAgc2V0SXNHZXR0aW5nTG9jYXRpb24oZmFsc2UpO1xuICAgICAgICAgIFxuICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSAn7ZiE7J6sIOychOy5mOulvCDqsIDsoLjsmKwg7IiYIOyXhuyKteuLiOuLpC4nO1xuICAgICAgICAgIFxuICAgICAgICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgICAgICAgY2FzZSBlcnJvci5QRVJNSVNTSU9OX0RFTklFRDpcbiAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ+ychOy5mCDqtoztlZzsnbQg6rGw67aA65CY7JeI7Iq164uI64ukLiDruIzrnbzsmrDsoIAg7ISk7KCV7JeQ7IScIOychOy5mCDqtoztlZzsnYQg7ZeI7Jqp7ZW07KO87IS47JqULic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBlcnJvci5QT1NJVElPTl9VTkFWQUlMQUJMRTpcbiAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ+ychOy5mCDsoJXrs7Trpbwg7IKs7Jqp7ZWgIOyImCDsl4bsirXri4jri6QuIEdQUyDsi6DtmLjrpbwg7ZmV7J247ZW07KO87IS47JqULic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBlcnJvci5USU1FT1VUOlxuICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAn7JyE7LmYIOygleuztCDsmpTssq3snbQg7Iuc6rCEIOy0iOqzvOuQmOyXiOyKteuLiOuLpC4g64uk7IucIOyLnOuPhO2VtOyjvOyEuOyalC4nO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGDsnITsuZgg7KCV67O0IOyYpOulmDogJHtlcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBhbGVydChlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIOuqqOuwlOydvOyXkOyEnOuKlCDsoJXtmZXrj4Qg64Ku7Law7IScIOyerOyLnOuPhFxuICAgICAgICAgIGlmIChpc01vYmlsZSAmJiBvcHRpb25zLmVuYWJsZUhpZ2hBY2N1cmFjeSAmJiBlcnJvci5jb2RlID09PSBlcnJvci5USU1FT1VUKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn7KCV7ZmV64+EIOuCruy2sOyEnCDsnqzsi5zrj4QuLi4nKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKFxuICAgICAgICAgICAgICAgIChwb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgeyBsYXRpdHVkZSwgbG9uZ2l0dWRlIH0gPSBwb3NpdGlvbi5jb29yZHM7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXdMb2NhdGlvbiA9IHsgbGF0OiBsYXRpdHVkZSwgbG5nOiBsb25naXR1ZGUgfTtcbiAgICAgICAgICAgICAgICAgIHNldFVzZXJMb2NhdGlvbihuZXdMb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgICBtb3ZlTWFwVG9Mb2NhdGlvbihuZXdMb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgICBzZXRJc0dldHRpbmdMb2NhdGlvbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAocmV0cnlFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign7J6s7Iuc64+EIOyLpO2MqDonLCByZXRyeUVycm9yKTtcbiAgICAgICAgICAgICAgICAgIHNldElzR2V0dGluZ0xvY2F0aW9uKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHsgLi4ub3B0aW9ucywgZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZSwgdGltZW91dDogMTUwMDAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgIH07XG5cbiAgICBnZXRMb2NhdGlvbigpO1xuICB9LCBbbW92ZU1hcFRvTG9jYXRpb25dKTtcblxuICByZXR1cm4ge1xuICAgIG1hcFJlZixcbiAgICBtYXBDZW50ZXIsXG4gICAgc2V0TWFwQ2VudGVyLFxuICAgIHVzZXJMb2NhdGlvbixcbiAgICBtYXBJbnN0YW5jZSxcbiAgICBtYXJrZXJzUmVmLFxuICAgIHBvbHlsaW5lUmVmLFxuICAgIG1vdmVNYXBUb0xvY2F0aW9uLFxuICAgIGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBpc0dldHRpbmdMb2NhdGlvblxuICB9O1xufTtcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwiREVGQVVMVF9DRU5URVIiLCJsYXQiLCJsbmciLCJpc01vYmlsZURldmljZSIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiZ2V0R2VvbG9jYXRpb25PcHRpb25zIiwiaXNNb2JpbGUiLCJlbmFibGVIaWdoQWNjdXJhY3kiLCJ0aW1lb3V0IiwibWF4aW11bUFnZSIsInVzZU1hcCIsIm1hcENlbnRlciIsInNldE1hcENlbnRlciIsInVzZXJMb2NhdGlvbiIsInNldFVzZXJMb2NhdGlvbiIsIm1hcEluc3RhbmNlIiwic2V0TWFwSW5zdGFuY2UiLCJpc0dldHRpbmdMb2NhdGlvbiIsInNldElzR2V0dGluZ0xvY2F0aW9uIiwibWFwUmVmIiwibWFya2Vyc1JlZiIsInBvbHlsaW5lUmVmIiwiY29uc29sZSIsImxvZyIsImN1cnJlbnQiLCJuYXZlciIsIm1hcHMiLCJ3YWl0Rm9yTWFwQ29udGFpbmVyIiwic2V0VGltZW91dCIsImluaXRNYXAiLCJtYXAiLCJNYXAiLCJjZW50ZXIiLCJMYXRMbmciLCJ6b29tIiwibWluWm9vbSIsIm1heFpvb20iLCJFdmVudCIsImFkZExpc3RlbmVyIiwiZ2V0Q2VudGVyIiwiZXJyb3IiLCJtZXNzYWdlIiwic3RhY2siLCJmb3JFYWNoIiwibWFya2VyIiwic2V0TWFwIiwic2V0Q2VudGVyIiwibW92ZU1hcFRvTG9jYXRpb24iLCJjb29yZHMiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJsb2NhdGlvbiIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJhbGVydCIsImdlb2xvY2F0aW9uIiwid2FybiIsIm9wdGlvbnMiLCJwZXJtaXNzaW9ucyIsInF1ZXJ5IiwibmFtZSIsInRoZW4iLCJyZXN1bHQiLCJzdGF0ZSIsImNhdGNoIiwiZ2V0TG9jYXRpb24iLCJnZXRDdXJyZW50UG9zaXRpb24iLCJwb3NpdGlvbiIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiYWNjdXJhY3kiLCJuZXdMb2NhdGlvbiIsImVycm9yTWVzc2FnZSIsImNvZGUiLCJQRVJNSVNTSU9OX0RFTklFRCIsIlBPU0lUSU9OX1VOQVZBSUxBQkxFIiwiVElNRU9VVCIsInJldHJ5RXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/hooks/useMap.js\n"));

/***/ })

});